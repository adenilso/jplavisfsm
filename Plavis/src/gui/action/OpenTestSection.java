 /*
 *  JFLAP - Formal Languages and Automata Package
 * 
 * 
 *  Susan H. Rodger
 *  Computer Science Department
 *  Duke University
 *  August 27, 2009

 *  Copyright (c) 2002-2009
 *  All rights reserved.

 *  JFLAP is open source software. Please see the LICENSE for terms.
 *
 */





package gui.action;

import file.BasicFileReader;
import file.BasicFileWriter;
import grammar.Grammar;
//import grammar.parse.BruteParser;
//import grammar.parse.BruteParserEvent;
//import grammar.parse.BruteParserListener;
import automata.fsa.FSAStepByStateSimulator;
import automata.mealy.*;
import gui.JTableExtender;
import gui.SplitPaneFactory;
import gui.TableTextSizeSlider;
import gui.action.CreateTestSectionAction.MultiplePane;
import gui.editor.ArrowDisplayOnlyTool;
import gui.editor.EditorPane;
import gui.environment.AutomatonEnvironment;
import gui.environment.Environment;
import gui.environment.EnvironmentFactory;
import gui.environment.EnvironmentFrame;
import gui.environment.FrameFactory;
import gui.environment.GrammarEnvironment;
import gui.environment.Profile;
import gui.environment.Universe;
import gui.environment.EnvironmentFactory.EditorPermanentTag;
import gui.environment.tag.CriticalTag;
import gui.environment.tag.Tag;
import gui.grammar.GrammarInputPane;
import gui.grammar.parse.BruteParsePane;
import gui.grammar.parse.UnrestrictedTreePanel;
import gui.sim.TraceWindow;
import gui.sim.multiple.InputTableModel;
import gui.viewer.AutomatonPane;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.JToolBar;
import javax.swing.KeyStroke;
import javax.swing.Timer;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import javax.swing.tree.TreeNode;

import mutants.Mutant;
import mutants.MutantsCreator;
import mutants.Status;

import tool.fsm.reader.FsmReader;

//import com.sun.org.apache.xalan.internal.xsltc.compiler.Parser;

import automata.Automaton;
import automata.AutomatonSimulator;
import automata.Configuration;
import automata.NondeterminismDetector;
import automata.NondeterminismDetectorFactory;
import automata.SimulatorFactory;
import automata.State;
import automata.Transition;
import automata.turing.TMSimulator;
import automata.turing.TuringMachine;

import fsm4ws.FiniteStateMachine;
import fsm4ws.generationMethod.*;

/**
 * This is the action used for the simulation of multiple inputs on an automaton
 * with no interaction. This method can operate on any automaton.
 * 
 * @author Thomas Finley
 * @modified by Kyung Min (Jason) Lee
 */

public class OpenTestSection extends MultipleSimulateAction {
	/**
	 * Instantiates a new <CODE>MultipleSimulateAction</CODE>.
	 * 
	 * @param automaton
	 *            the automaton that input will be simulated on
	 * @param environment
	 *            the environment object that we shall add our simulator pane to
	 */
	public OpenTestSection(Automaton automaton, Environment environment) {
		super(automaton, environment);
		putValue(NAME, "Open");
        putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_T,
                MAIN_MENU_MASK));
        
        //this.plavisEncode = writeFieldsPlavis(automaton);
        this.automaton = automaton;
        this.environment = environment;
        
	}

	
	/**
	 * Returns the title for the type of compontent we will add to the
	 * environment.
	 * 
	 * @return in this base class, returns "Multiple Inputs"
	 */
	public String getComponentTitle() {
		return "Test Section";
	}

	/**
	 * This will search configurations for an accepting configuration.
	 * 
	 * @param automaton
	 *            the automaton input is simulated on
	 * @param simulator
	 *            the automaton simulator for this automaton
	 * @param configs
	 *            the initial configurations generated from a single input
	 * @param initialInput
	 *            the object that represents the initial input; this is a String
	 *            object in most cases, but for Turing Machines is an array of
	 *            String objects
	 * @param associatedConfigurations
	 *            the first accepting configuration encountered will be added to
	 *            this list, or the last configuration considered if there was
	 *            no accepted configuration
	 * @return <CODE>0</CODE> if this was an accept, <CODE>1</CODE> if
	 *         reject, and <CODE>2</CODE> if the user cancelled the run
	 */
	protected int handleInput(Automaton automaton,
			AutomatonSimulator simulator, Configuration[] configs,
			Object initialInput, List associatedConfigurations) {
		JFrame frame = Universe.frameForEnvironment(getEnvironment());
		// How many configurations have we had?
		int numberGenerated = 0;
		// When should the next warning be?
		int warningGenerated = WARNING_STEP;
		Configuration lastConsidered = configs[configs.length - 1];
		while (configs.length > 0) {
			numberGenerated += configs.length;
			// Make sure we should continue.
			if (numberGenerated >= warningGenerated) {
				if (!confirmContinue(numberGenerated, frame)) {
					associatedConfigurations.add(lastConsidered);
					return 2;
				}
				while (numberGenerated >= warningGenerated)
					warningGenerated *= 2;
			}
			// Get the next batch of configurations.
			ArrayList next = new ArrayList();
			for (int i = 0; i < configs.length; i++) {
				lastConsidered = configs[i];
				if (configs[i].isAccept()) {
					associatedConfigurations.add(configs[i]);
					return 0;
				} else {
					next.addAll(simulator.stepConfiguration(configs[i]));
				}
			}
			configs = (Configuration[]) next.toArray(new Configuration[0]);
		}
		associatedConfigurations.add(lastConsidered);
		return 1;
	}

	/**
	 * Provides an initialized multiple input table object.
	 * 
	 * @param obj
	 *            the automaton to provide the multiple input table for
	 * @return a table object for this automaton
	 * @see gui.sim.multiple.InputTableModel
	 */
	protected JTableExtender initializeTable(Object obj) {
//		System.out.println("In regular multiple initialize");
		boolean multiple = false;
		int inputCount = 0;
        if(this.getEnvironment().myObjects!=null){
        	multiple = true;
        	inputCount = 1;
        }
        //System.out.println("In initialize:" + multiple);
        InputTableModel model = null;
        if(getObject() instanceof Automaton){
        	model = InputTableModel.getModel((Automaton)getObject(), multiple);
        }
        else if(getObject() instanceof Grammar) model = InputTableModel.getModel((Grammar)getObject(), multiple);
		JTableExtender table = new JTableExtender(model, this);
		// In this regular multiple simulate pane, we don't care about
		// the outputs, so get rid of them.
		TableColumnModel tcmodel = table.getColumnModel();
		
		
		inputCount += model.getInputCount();
		for (int i = model.getInputCount(); i > 0; i--) {
			tcmodel.removeColumn(tcmodel.getColumn(inputCount));
		}
		if(multiple){
            ArrayList autos  = this.getEnvironment().myObjects;
            //System.out.println("In initialize: " + autos.size());
            ArrayList strings = this.getEnvironment().myTestStrings;
            int offset = strings.size();
            int row = 0;
            for(int m = 0; m < autos.size(); m++){      
                for(int k = 0; k < strings.size(); k++){
                    row = k+offset*m;
                    Object currentObj = autos.get(m);
                    if(currentObj instanceof Automaton){
                    	model.setValueAt(((Automaton)currentObj).getFileName(), row, 0); 
                    	 model.setValueAt((String)strings.get(k), row, 1);                    	
                    }
                    else if(currentObj instanceof Grammar){
                    	model.setValueAt(((Grammar)currentObj).getFileName(), row, 0); 
                    	 model.setValueAt((String)strings.get(k), row, 1);
                    }                  
                }
                
            }
            while((model.getRowCount()-1) > (autos.size()*strings.size())){
            	model.deleteRow(model.getRowCount()-2);
            }
		}
				
		// Set up the last graphical parameters.
		table.setShowGrid(true);
		table.setGridColor(Color.lightGray);
		
		//table.setEnabled(false);
		table.setCellSelectionEnabled(false);
		
		return table;
	}
	
	public void performAction(Component source){
		
		
		if(getObject() instanceof Automaton){
			if (((Automaton)getObject()).getInitialState() == null) {
				JOptionPane.showMessageDialog(source,
						"Simulation requires an automaton\n"
								+ "with an initial state!", "No Initial State",
						JOptionPane.ERROR_MESSAGE);
				return;
			}
		}
        /*
         * If it is a Mealy or Moore machine, it cannot have nondeterminism.
         */
        if(getObject() instanceof MealyMachine) {
            Automaton a = (Automaton)getObject();
            NondeterminismDetector d = NondeterminismDetectorFactory.getDetector(a);
            State[] nd = d.getNondeterministicStates(a);
            if(nd.length > 0){
                JOptionPane.showMessageDialog(source, 
                    "Please remove nondeterminism for simulation.\n" +
                    "Select menu item Test : Highlight Nondeterminism\n" +
                    "to see nondeterministic states.",
                    "Nondeterministic states detected", JOptionPane.ERROR_MESSAGE);
                return;
            }
        }
		
		
		JFileChooser ourChooser = new JFileChooser (System.getProperties().getProperty("user.dir"));
		
		
		ourChooser.setFileFilter(new javax.swing.filechooser.FileFilter(){  
			public boolean accept(File f){  
			return (f.getName().endsWith(".ptf")) || f.isDirectory();  
			}  
			public String getDescription(){  
			     return "Plavis Test File";  
			}  
		}); 
		
		int retval=ourChooser.showOpenDialog(null);
		File f=null;
		

		
		table = initializeTable(getObject());
		InputTableModel model = (InputTableModel) table.getModel();
		model.clear();
		
		/*Teste*/ 
		/** LOGGER - Begin */
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");  
		getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Generate Mutants: START");
		/** LOGGER - End */
		
		MutantsCreator Mutants = new MutantsCreator(automaton);
		ArrayList<Mutant> mutantsList = Mutants.createMutants();	
		
		/** LOGGER - Begin */
		getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Generate Mutants: "+ mutantsList.size() +" mutants - END");
		/** LOGGER - End */
		
	
		File fLocalDir = new File("").getAbsoluteFile();
		String strLocalDir = fLocalDir.getPath();
    	String separator = "";
		BasicFileReader configFile = new BasicFileReader(strLocalDir+"//config.txt");
						
		if(configFile.open()){
			separator = configFile.readLine();
			if(separator.equalsIgnoreCase("DEFAULT"))
				separator = ",";
			else if(separator.equalsIgnoreCase("SPACE"))
				separator = " ";
			else if(separator.equalsIgnoreCase("NOTHING") || separator.equalsIgnoreCase(""))
				separator = "";
			configFile.close();
		}
		else{
			separator = ",";
		}
		
		
		if (retval==JFileChooser.APPROVE_OPTION)
		{
			f=ourChooser.getSelectedFile();
//			try 
//			{
			/** LOGGER - Begin */
			this.environment.getLogArea().append("\n" + sdf.format(new Date()) + " - Open Test Section: " + f.getAbsolutePath());
			/** LOGGER - End */
			
				String separatorFile = "";
				//Scanner sc=new Scanner(f);
				BasicFileReader bfr = new BasicFileReader(f.getAbsolutePath());
				
				int last=model.getRowCount()-1;
				boolean first = true;
				if(bfr.open()){
					//while (sc.hasNext())
					while(!bfr.endOfFile())
					{
						String temp = bfr.readLine(); //sc.next();
						System.out.println(temp);
						if(first){
							separatorFile = temp;
							if(separatorFile.equalsIgnoreCase("DEFAULT"))
								separatorFile = ",";
							else if(separatorFile.equalsIgnoreCase("SPACE"))
								separatorFile = " ";
							else if(separatorFile.equalsIgnoreCase("NOTHING") || separator.equalsIgnoreCase(""))
								separatorFile = "";
							
						}
						else{
							temp = temp.replaceAll(separatorFile, separator);
							model.setValueAt(temp, last, 0);
							last++;
						}	
						first = false;
					}
				}
//			}
//			catch (FileNotFoundException e1) {
//				// TODO Auto-generate catch block
//				e1.printStackTrace();
//			}
		}
		else return;
			
		
		
       // table = initializeTable(getObject());
        
		if(((InputTableModel)table.getModel()).isMultiple){
			getEnvironment().remove(getEnvironment().getActive());
		}
		
		JPanel panel = new JPanel(new BorderLayout());
		JPanel panelBar = new JPanel(new BorderLayout());
		JToolBar bar = new JToolBar();
		JToolBar bar2 = new JToolBar();
		panel.add(new JScrollPane(table), BorderLayout.CENTER);
		panelBar.add(bar2, BorderLayout.SOUTH);
		panelBar.add(bar, BorderLayout.CENTER);
		panel.add(new TableTextSizeSlider(table), BorderLayout.NORTH);
	
		//Where are the test cases obtained
		fLocalDir = new File("").getAbsoluteFile();
		strLocalDir = fLocalDir.getPath()+"//Methods";
		File fMethodsDir = new File(strLocalDir);
			
		/*Teste*/ //System.out.println("teste: "+fMethodsDir.getPath());
		
		final JComboBox jMethodsList = new JComboBox ();
		//**** METHODS LIST
		jMethodsList.addItem("W");
		jMethodsList.addItem("HSI"); //New Method - Oct 4th 2011
		jMethodsList.addItem("SPY"); //New Method - Oct 4th 2011
		jMethodsList.addItem("UIO"); //New Method - Oct 5th 2011
		//jMethodsList.addItem("Condado");
		jMethodsList.addItem("From File");
		File[] fMethods = fMethodsDir.listFiles();
		if(fMethodsDir.exists() && fMethods.length>0){
			for(int i = 0; i < fMethodsDir.listFiles().length; i++){
				if(!fMethods[i].isDirectory() && (!fMethods[i].getName().endsWith(".sh")) &&
				  (!fMethods[i].getName().equals("n-complete")) &&
				  (!fMethods[i].getName().equals("uio")) &&
				  (!fMethods[i].getName().equals("spy")) &&
				  (!fMethods[i].getName().equals("fsm-hsi")) && (!fMethods[i].getName().endsWith(".txt")) &&
				(fMethods[i].canExecute() || fMethods[i].getName().endsWith(".jar")) ){
					jMethodsList.addItem(fMethods[i].getName());
					System.out.println(fMethods[i].getName());
				}
			}
			
		}
		else{
			fMethodsDir.mkdir(); //Command to create a new directory methods
		}		
		jMethodsList.setMaximumSize(new Dimension(85, 25));
		
//		InputTableModel model = (InputTableModel) table.getModel();          
//		model.clear();
		
		
		//Load Mutants
		/** LOGGER - Begin */
		getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Load Mutants Status");
		/** LOGGER - End */
		
		if(getObject() instanceof Automaton){
            Automaton currentAuto = (Automaton)getObject();
			AutomatonSimulator simulator = SimulatorFactory
					.getSimulator(currentAuto);
			String[][] inputs = model.getInputs();
	        int uniqueInputs = inputs.length;
	        int tapes = 1;
	        if(model.isMultiple){
	        	if (currentAuto instanceof TuringMachine) {
					 tapes = ((TuringMachine)currentAuto).tapes;
	        	}
	            uniqueInputs = getEnvironment().myTestStrings.size()/tapes;
	        }
	        
	        for (int r = 0; r < inputs.length; r++) {
	            if(r>0){
	                if(r%uniqueInputs==0){
	                    currentAuto = (Automaton)getEnvironment().myObjects.get(r/uniqueInputs);
	                   
	                    simulator = SimulatorFactory.getSimulator(currentAuto);                         
	                }
	            }
				Configuration[] configs = null;
				Object input = null;
				// Is this a Turing machine?
				if (currentAuto instanceof TuringMachine) {
					 
					configs = ((TMSimulator) simulator)
							.getInitialConfigurations(inputs[r]);
					input = inputs[r];
				} else { // If it's not a Turing machine.
					configs = simulator
							.getInitialConfigurations(inputs[r][0]);
					input = inputs[r][0];
				}
				List associated = new ArrayList();
				int result = handleInput(currentAuto, simulator,
						configs, input, associated);
				Configuration c = null;
				String out = null;
				
				if (associated.size() != 0){
					c = (Configuration) associated.get(0);
					out = c.toString().substring(c.toString().lastIndexOf(":"));
					//System.out.println("O"+c.toString());
				}

				
				BasicFileReader fileReader = null;
				if(f != null || f.length() > 0){
					String path = f.getAbsolutePath();
					path = path.replace(".ptf", "_status.ptsf");
					fileReader = new BasicFileReader(path);
				}
			
				if(fileReader.open()){	
					Iterator<Mutant> itMut = mutantsList.iterator();
					while(itMut.hasNext()){
						String[] line = fileReader.readLine().split(" ");
						
						Mutant mut = itMut.next();
						try{
							mut.setStatus(Integer.parseInt(line[0]));
							if(mut.getStatus() == Status.DEAD){
								for(int i = 1; i < line.length; i++){
									
									String test = inputs[Integer.parseInt(line[i])][0];
									if(isAlreadyExecuted(mut.getTestCases(), test)){
										mut.addTestCase(test);
									}
					
								}
							}	
						}
						catch(NumberFormatException e){
							System.err.println("The test section doesn't match with the open fsm");
						}
					}
				}
			}
	       
		}
		
		
		//Create Gui
		bar.add(jMethodsList);
		
		//Load inputs
		bar.add(new LoadInputsAction(automaton, environment, table, jMethodsList, fMethodsDir.getPath()));

		// Add the running input thing.
		bar.add(new RunInputsAction(environment, automaton, table, mutantsList, f));

		if(!((InputTableModel)table.getModel()).isMultiple){
		// Add the clear button.
		bar.add(new AbstractAction("Clear Inactives") {
			public void actionPerformed(ActionEvent e) {
				try {
					// Make sure any recent changes are registered.
					table.getCellEditor().stopCellEditing();
				} catch (NullPointerException exception) {
					// We weren't editing anything, so we're OK.
				}
				
				/** LOGGER - Begin *//** LOGGER - Begin */
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");  
				getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Clear Inactives Test Cases");
				/** LOGGER - End */
				
				InputTableModel model = (InputTableModel) table.getModel();              
				String[][] inputs = model.getInputs();
				for (int r = 0; r < inputs.length; r++) {
					if(inputs[r][0].startsWith("#")){
						model.setValueAt("", r, 0);
					}
				}
				
				

			}
		});
		
		bar.add(new AbstractAction("Clear All") {
			public void actionPerformed(ActionEvent e) {
				try {
					// Make sure any recent changes are registered.
					table.getCellEditor().stopCellEditing();
				} catch (NullPointerException exception) {
					// We weren't editing anything, so we're OK.
				}
				
				/** LOGGER - Begin *//** LOGGER - Begin */
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");  
				getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Clear All Test Cases");
				/** LOGGER - End */
				
				InputTableModel model = (InputTableModel) table.getModel();              
				model.clear();
			}
		});
		
		bar2.add(new AbstractAction("Prefix") {
			public void actionPerformed(ActionEvent e) {
				try {
					// Make sure any recent changes are registered.
					table.getCellEditor().stopCellEditing();
				} catch (NullPointerException exception) {
					// We weren't editing anything, so we're OK.
				}
				
				/** LOGGER - Begin *//** LOGGER - Begin */
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");  
				getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Prefix: This marks with \"#\" test cases that are prefixes of other");
				/** LOGGER - End */
				
				InputTableModel model = (InputTableModel) table.getModel();              
				String[][] inputs = model.getInputs();
				for (int r = 0; r < inputs.length; r++) {
					for(int s = 0; s < inputs.length; s++) {	
						if(r!=s){
							if(!inputs[r][0].startsWith("#") && inputs[s][0].startsWith(inputs[r][0])){
								inputs[r][0] = "#"+inputs[r][0];
								model.setValueAt(inputs[r][0], r, 0);
							}
							if(!inputs[s][0].startsWith("#") && inputs[r][0].startsWith(inputs[s][0])){
								inputs[s][0] = "#"+inputs[s][0];
								model.setValueAt(inputs[s][0], s, 0);
							}
							
						}
					}
				}
				
				/** LOGGER - Begin *//** LOGGER - Begin */
				getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - Prefix (\"#\"): END ");
				/** LOGGER - End */

			}
		});
		
		bar2.add(new ShowMutantsAction(environment, automaton, mutantsList));

		bar2.add(new ExportInputsAction(this.environment, table, f, mutantsList));
			
		bar2.add(new AbstractAction("n-Complete") {
			
			@Override
			public void actionPerformed(ActionEvent arg0) {
			
				/** LOGGER - Begin *//** LOGGER - Begin */
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");  
				getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - n-Complete: START");
				/** LOGGER - End */
				
				//Process: ./n-complete initial1.txt < fsm1.txt
				File fLocalDir = new File("").getAbsoluteFile();
				String strLocalDir = fLocalDir.getPath()+"//Methods";
				File Dir = new File(strLocalDir);
				
				try {
					// Make sure any recent changes are registered.
					table.getCellEditor().stopCellEditing();
				} catch (NullPointerException exception) {
					// We weren't editing anything, so we're OK.
				}
				InputTableModel model = (InputTableModel) table.getModel();              
				String[][] inputs = model.getInputs();
				if(inputs.length <= 0){
					JOptionPane.showMessageDialog(null, 
		                    "The table is empty - There is no inputs to verify!",
		                    "Complete set", JOptionPane.INFORMATION_MESSAGE);
					return;
				}
				
				File fLocalDir2 = new File("").getAbsoluteFile();
				String strLocalDir2 = fLocalDir2.getPath();
				String separator = "";
				BasicFileReader configFile = new BasicFileReader(strLocalDir2+"//config.txt");
								
				if(configFile.open()){
					separator = configFile.readLine();
					if(separator.equalsIgnoreCase("DEFAULT"))
						separator = ",";
					else if(separator.equalsIgnoreCase("SPACE"))
						separator = " ";
					else if(separator.equalsIgnoreCase("NOTHING") || separator.equalsIgnoreCase(""))
						separator = "";
					configFile.close();
				}
				else{
					separator = ",";
				}
				
				BasicFileWriter writer = new BasicFileWriter(strLocalDir+"//fsmOUT.txt");
				if(writer.open()){
					for (int r = 0; r < inputs.length; r++) {
						//@TEST - It's just because the n-complete doesn't understand "," as separator char
						String str = inputs[r][0].replaceAll(separator, " ");
						writer.writeLine(str+"\n");
//						writer.writeLine(inputs[r][0]+"\n");
					}
					writer.close();
				}
				
				
				try{
					Process process = Runtime.getRuntime().exec("./n-complete.sh", null, Dir);
					int i = process.waitFor();
					System.out.println("n-complete: "+i);
					if(i==0){
						JOptionPane.showMessageDialog(null, 
			                    "The test set is complete",
			                    "Complete set", JOptionPane.INFORMATION_MESSAGE);
					}
					else{
						JOptionPane.showMessageDialog(null, 
			                    "The test set is NOT complete",
			                    "Complete set", JOptionPane.ERROR_MESSAGE);
					}
					
					OutputStream os = process.getOutputStream();
				      
			        InputStream is = process.getInputStream();
			        BufferedReader bf = new BufferedReader(new InputStreamReader(is));
				}
				catch(Exception e){
					e.printStackTrace();
				}
					
				/** LOGGER - Begin *//** LOGGER - Begin */
				getEnvironment().getLogArea().append("\n" + sdf.format(new Date()) + " - n-Complete: END");
				/** LOGGER - End */
			}
		});
		
		
		bar2.add(new AbstractAction("TC Counter") {
			
			@Override
			public void actionPerformed(ActionEvent arg0) {
				
				InputTableModel model = (InputTableModel) table.getModel();
				String[][] inputs = model.getInputs();
				int disabled = 0;
				for (int r = 0; r < inputs.length; r++) {
					if(inputs[r][0].startsWith("#")) disabled++;					
				}
				
				JOptionPane.showMessageDialog(null, 
	                    "TOTAL: " + inputs.length + " (Actives: "+ (inputs.length - disabled) + " / Inactives: "+disabled+")",
	                    "Test Cases Generated", JOptionPane.INFORMATION_MESSAGE);
				
				
				
			}
		});
		
		
		}
//		if(getObject() instanceof Automaton) {
//			bar2.add(new AbstractAction("View Trace") {
//			public void actionPerformed(ActionEvent e) {
//				int[] rows = table.getSelectedRows();
//				InputTableModel tm = (InputTableModel) table.getModel();
//				List nonassociatedRows = new ArrayList();
//				for (int i = 0; i < rows.length; i++) {
//					if (rows[i] == tm.getRowCount() - 1)
//						continue;
//					Configuration c = tm
//							.getAssociatedConfigurationForRow(rows[i]);
//					if (c == null) {
//						nonassociatedRows.add(new Integer(rows[i] + 1));
//						continue;
//					}
//					TraceWindow window = new TraceWindow(c);
//					window.setVisible(true);
//					window.toFront();
//				}
//				// Print the warning message about rows without
//				// configurations we could display.setValueAt
//				if (nonassociatedRows.size() > 0) {
//					StringBuffer sb = new StringBuffer("Row");
//					if (nonassociatedRows.size() > 1)
//						sb.append("s");
//					sb.append(" ");
//					sb.append(nonassociatedRows.get(0));
//					for (int i = 1; i < nonassociatedRows.size(); i++) {
//						if (i == nonassociatedRows.size() - 1) {
//							// Last one!
//							sb.append(" and ");
//						} else {
//							sb.append(", ");
//						}
//						sb.append(nonassociatedRows.get(i));
//					}
//					sb.append("\ndo");
//					if (nonassociatedRows.size() == 1)
//						sb.append("es");
//					sb.append(" not have end configurations.");
//					JOptionPane.showMessageDialog((Component) e.getSource(), sb
//							.toString(), "Bad Rows Selected",
//							JOptionPane.ERROR_MESSAGE);
//				}
//			}
//		});
//		}
		if(((InputTableModel)table.getModel()).isMultiple){
		    
		    bar.add(new AbstractAction("Edit File"){
		        public void actionPerformed(ActionEvent arg0) {		            
		            int k = getMachineIndexBySelectedRow(table);
		            if(k>=0 && k < getEnvironment().myObjects.size()){
		                if(getObject() instanceof Automaton){
		                    Automaton cur = (Automaton)getEnvironment().myObjects.get(k);
		                    EditorPane ep = new EditorPane(cur);
		                    ep.setName(cur.getFileName());
		                    getEnvironment().add(ep, "Edit", new CriticalTag() {
		                    });
		                    getEnvironment().setActive(ep);          
		                }
		                
		                else if(getObject() instanceof Grammar){
		                    Grammar cur = (Grammar)getEnvironment().myObjects.get(k);
		                    GrammarInputPane ep = new GrammarInputPane(cur);      
		                    ep.setName(cur.getFileName());
		                    getEnvironment().add(ep, "Edit", new CriticalTag() {
		                    });
		                    getEnvironment().setActive(ep);
		                }
                    }	            
		        }
		    });
		    
        	bar.add(new AbstractAction("Add input string"){
        		public void actionPerformed(ActionEvent arg0) {
                    //add input
                    int inputsNeeded = 1;
                    boolean turing = false;
        			if(getEnvironment().myObjects.get(0) instanceof TuringMachine){      			 
                        turing = true;
                    }
                        Object input = initialInput((Component) getEnvironment().getActive(), "Input");
    
            			if(input instanceof String){
            				String s = (String)input;
            				((ArrayList)getEnvironment().myTestStrings).add(s);
            			}
            			else if(input instanceof String[]){
            				String[] s = (String[]) input;
                            for(int k = 0; k < s.length; k++){
                                ((ArrayList)getEnvironment().myTestStrings).add(s[k]);
                            }
            			}
                        else return;
                    
                    //add expected output
                    if(turing){
                            Object output = initialInput((Component) getEnvironment().getActive(), "Expected Output?");
        
    
                            if(output instanceof String){
                                String s = (String)output;
                                ((ArrayList)getEnvironment().myTransducerStrings).add(s);
                            }
                            else if(output instanceof String[]){
                                String[] s = (String[]) output;
                                for(int k = 0; k < s.length; k++){
                                    ((ArrayList)getEnvironment().myTransducerStrings).add(s[k]);
                                }
                            }
                            else{
                                getEnvironment().myTestStrings.remove(getEnvironment().myTestStrings.size()-1);
                                return;
                            }
                        
                    }
                    //add expected result
                    Object result = initialInput((Component) getEnvironment().getActive(), "Expected Result? (Accept or Reject)");

                    if(result instanceof String){
                        String s = (String)result;
                        ((ArrayList)getEnvironment().myTransducerStrings).add(s);
                    }
                    else if(result instanceof String[]){
                        String[] s = (String[]) result;
                        ((ArrayList)getEnvironment().myTransducerStrings).add(s[0]);
                    }
                    else {
                        getEnvironment().myTestStrings.remove(getEnvironment().myTestStrings.size()-1);
                        getEnvironment().myTransducerStrings.remove(getEnvironment().myTestStrings.size()-1);
                        return;
                    }
                    
        			getEnvironment().remove(getEnvironment().getActive());
                    performAction(getEnvironment().getActive());
                    
                }
            	});
        	
        	bar.add(new AbstractAction("Add file"){
        		public void actionPerformed(ActionEvent arg0) {
        			TestAction test = new TestAction();
        			test.chooseFile(getEnvironment().getActive(), false);
        			getEnvironment().remove(getEnvironment().getActive());
                    performAction(getEnvironment().getActive());
                }
            });
        	
        	bar.add(new AbstractAction("Remove file"){
        		public void actionPerformed(ActionEvent arg0) {
        			int k = getMachineIndexBySelectedRow(table);
                    if(k>=0 && k < getEnvironment().myObjects.size()){
            			getEnvironment().myObjects.remove(k);
            			int row = table.getSelectedRow();
       			
            			int objSize = getEnvironment().myObjects.size();
            			int stringSize = getEnvironment().myTestStrings.size();
            			
            			int beginOffset = row%stringSize;
            			int begin = (row-beginOffset);
            			
            			for(int i = 0; i < (stringSize); i++){
            				((InputTableModel)table.getModel()).deleteRow(begin);      				
            		 }  
            			table.changeSelection(0,0, false, false);
                    }
                }
            	});
        	
        	bar.add(new AbstractAction("Save Results"){
        	    public void actionPerformed(ActionEvent arg0) {
        	        final JFrame frame = new JFrame("Save Location");
        	        
        	        
        	        final JRadioButton defaultLocation = new JRadioButton("Save Results with Original File");
        	        defaultLocation.setMnemonic(KeyEvent.VK_B);
        	        defaultLocation.setActionCommand("Save Results with Original File");
        	        defaultLocation.addActionListener(new ActionListener() {
        	            public void actionPerformed(ActionEvent event){
        	            }
        	        });
        	        final JRadioButton specifyLocation = new JRadioButton("Specify New Location");
        	        specifyLocation.addActionListener(new ActionListener() {
        	            public void actionPerformed(ActionEvent event){
        	            }
        	        });
        	        specifyLocation.setMnemonic(KeyEvent.VK_C);
        	        specifyLocation.setActionCommand("Specify New Location");
        	        defaultLocation.setSelected(true);
        	        ButtonGroup group = new ButtonGroup();
        	        group.add(defaultLocation);
        	        group.add(specifyLocation);
        	        
        	        
        	        JPanel panel = new JPanel();
        	        panel.add(defaultLocation);
        	        panel.add(specifyLocation);
        	        frame.getContentPane().add(panel, BorderLayout.CENTER);
        	        
        	        JButton accept = new JButton("Accept");
        	        accept.addActionListener(new ActionListener() {
        	            public void actionPerformed(ActionEvent event) {
        	                frame.setVisible(false);
                            String filepath = "";
                            boolean failedSave = false;
        	                if(specifyLocation.isSelected()){
        	                    //                                  The save as loop.
        	                    File file = null;
        	                    boolean badname = false;
        	                    while (badname || file ==null) {
        	                        if (!badname) {
                                        Universe.CHOOSER.setFileFilter(null);
                                        Universe.CHOOSER.setDialogTitle("Choose directory to save files in");
                                        Universe.CHOOSER.setFileSelectionMode(Universe.CHOOSER.DIRECTORIES_ONLY);
        	                            int result = Universe.CHOOSER.showSaveDialog(frame);
        	                            if (result != JFileChooser.APPROVE_OPTION)
        	                                break;
        	                            file = Universe.CHOOSER.getSelectedFile();
        	                            
        	                            try {
        	                                // Get the suggested file name.
        	                                filepath = file.getCanonicalPath();
                                            int last = filepath.lastIndexOf("\\");
                                            if(last == -1) filepath = filepath+"/";
                                            else filepath = filepath+"\\";
        	                                
        	                            }
        	                            catch (IOException e) {
        	                                // TODO Auto-generated catch block
        	                                e.printStackTrace();
        	                            }
        	                        }
        	                    }
        	                }
                            if(filepath.equals("")) failedSave = true;
        	                InputTableModel model = (InputTableModel)table.getModel();
        	                String oldfileName = (String)model.getValueAt(0, 0);
        	                String fileName = (String)model.getValueAt(0, 0);
        	                boolean turing = false;
        	                Object machine = getEnvironment().myObjects.get(0);
        	                String base = filepath;
        	                if(machine instanceof Automaton){
        	                    if(machine instanceof TuringMachine){
        	                        turing = true;
        	                    }
        	                    if(failedSave) base = ((Automaton)machine).getFilePath();
        	                }
        	                else if(machine instanceof Grammar){
        	                    if(failedSave) base = ((Grammar)machine).getFilePath();
        	                }
        	                
        	                
        	                try{
            	                FileWriter writer = new FileWriter(base+"results"+fileName+".txt");   
            	                BufferedWriter bwriter = new BufferedWriter(writer);
            	                PrintWriter out = new PrintWriter(bwriter);;
            	                for(int r = 0; r<model.getRowCount(); r++){
            	                    fileName = (String)model.getValueAt(r, 0);                      
            	                    if(!fileName.equals(oldfileName)){
            	                        oldfileName = fileName;  
            	                        out.flush();
            	                        out.close();
            	                        if(fileName.equals("")) break;
            	                        int index = getMachineIndexByName(fileName);
            	                        machine = getEnvironment().myObjects.get(index);
            	                        if(machine instanceof Automaton){                                 
            	                            if(!specifyLocation.isSelected() || failedSave) base = ((Automaton)machine).getFilePath();
            	                        }
            	                        else if(machine instanceof Grammar){
                                            if(!specifyLocation.isSelected() || failedSave) base = ((Grammar)machine).getFilePath();
            	                        }
            	                        bwriter = new BufferedWriter(new FileWriter(base+"results"+fileName+".txt"));
            	                        out = new PrintWriter(bwriter);
            	                    }
            	                    boolean input = false;
            	                    boolean end = false;
            	                    boolean output = false;
            	                    
            	                    for(int c = 1; c < model.getColumnCount(); c++){   
            	                        if((((String)model.getColumnName(c)).startsWith("Input")) && !input){
            	                            out.write("Input: ");
            	                            input = true;
            	                        }
            	                        if((((String)model.getColumnName(c)).startsWith("Output")) && !output && turing){
            	                            out.write("Output: ");
            	                            output = true;
            	                        }
            	                        if(((String)model.getColumnName(c)).startsWith("Result")){
            	                            end = true;
            	                            out.write("Result: ");
            	                        }
            	                        String value = (String)model.getValueAt(r, c);
            	                        
            	                        out.write(value+" ");
            	                        try {
            	                            if(end){
            	                                bwriter.newLine();
            	                            }
            	                        }
            	                        catch (IOException e) {
            	                            
            	                        }
            	                    }                          
            	                }
            	                out.close();
            	            }
                            catch(IOException e){
                                
                            }
                        }
            
        	        });
        	        
        	        frame.getContentPane().add(accept, BorderLayout.SOUTH);
        	        frame.pack();
        	        Point point = new Point(100, 50);
        	        frame.setLocation(point);
        	        frame.setVisible(true);
        	    }
        	});
        	
        }
        
        myPanel = panel;
		// Set up the final view.
        Object finObject = getObject();
        if(finObject instanceof Automaton){
        	AutomatonPane ap = new AutomatonPane((Automaton)finObject);
        	ap.addMouseListener(new ArrowDisplayOnlyTool(ap, ap.getDrawer()));
        	JSplitPane split = SplitPaneFactory.createSplit(getEnvironment(), false,
    				0.83, panel, panelBar);
        	MultiplePane mp = new MultiplePane(split);
        	JSplitPane split2 = SplitPaneFactory.createSplit(getEnvironment(), true,
				0.4, ap, mp);
        	MultiplePane mp2 = new MultiplePane(split2);
        	getEnvironment().add(mp2, getComponentTitle(), new CriticalTag() {
    		});
    		getEnvironment().setActive(mp2);
        	
        	
//        	AutomatonPane ap = new AutomatonPane((Automaton)finObject);
//        	ap.addMouseListener(new ArrowDisplayOnlyTool(ap, ap.getDrawer()));
//        	JSplitPane split = SplitPaneFactory.createSplit(getEnvironment(), true,
//				0.34, ap, panel);
//        	MultiplePane mp = new MultiplePane(split);
//        	getEnvironment().add(mp, getComponentTitle(), new CriticalTag() {
//    		});
//    		getEnvironment().setActive(mp);
        }
        else if(finObject instanceof Grammar){
        	BruteParsePane bp = new BruteParsePane((GrammarEnvironment)getEnvironment(), (Grammar)finObject, (InputTableModel)table.getModel());
        	bp.inputField.setEditable(false);
            if(getEnvironment().myTestStrings != null && getEnvironment().myTestStrings.size()>0) bp.inputField.setText((String)getEnvironment().myTestStrings.get(0));
        	JSplitPane split = SplitPaneFactory.createSplit(getEnvironment(), true,
    				0.5, bp, panel);
          
        	MultiplePane mp = new MultiplePane(split);
        	getEnvironment().add(mp, getComponentTitle(), new CriticalTag() {
    		});
    		getEnvironment().setActive(mp);
        }
            
		
	}
	
	private int getMachineIndexBySelectedRow(JTable table){
		InputTableModel model = (InputTableModel) table.getModel();
        int row = table.getSelectedRow();
        if(row < 0) return -1;
        String machineFileName = (String)model.getValueAt(row, 0);
        return getMachineIndexByName(machineFileName);
	}
	

	
	public int getMachineIndexByName(String machineFileName){
	        ArrayList machines = getEnvironment().myObjects;
	        if(machines == null) return -1;
	        for(int k = 0; k < machines.size(); k++){            
	            Object current = machines.get(k);
	            if(current instanceof Automaton){
	            	Automaton cur = (Automaton)current;
	            	if(cur.getFileName().equals(machineFileName)){
	            		return k;
	                }
	            }
	            else if(current instanceof Grammar){
	            	Grammar cur = (Grammar)current;
	            	if(cur.getFileName().equals(machineFileName)){
	            		return k;
	                }
	            }
	            
	        }
	        return -1;
	}
	
	public void viewAutomaton(JTableExtender table){
		InputTableModel model = (InputTableModel) table.getModel();
		 if(model.isMultiple){        	 			
	         int row = table.getSelectedRow();
	         if(row < 0) return;
	         String machineFileName = (String)model.getValueAt(row, 0);           
	         updateView(machineFileName, (String)model.getValueAt(row, 1), table); 
		 }
       else if(this.getEnvironment().getObject() instanceof Grammar){
       updateView(((Grammar)this.getEnvironment().getObject()).getFileName(), (String)model.getValueAt(table.getSelectedRow(), 1), table);
       }
       else if(this.getEnvironment().getObject() instanceof Automaton){
       updateView(((Automaton)this.getEnvironment().getObject()).getFileName(), (String)model.getValueAt(table.getSelectedRow(), 1), table);
   }
		
	}
	
	/**
	 * Handles the creation of the multiple input pane.
	 * 
	 * @param e
	 *            the action event
	 */
	public void actionPerformed(ActionEvent e) {
		performAction((Component)e.getSource());		
	}

	/**
	 * @param machineFileName
     * 
     */
    protected void updateView(String machineFileName, String input, JTableExtender table) {
        ArrayList machines = this.getEnvironment().myObjects;
        Object current = null;
        if(machines != null) current = machines.get(0);
        else current = this.getEnvironment().getObject();
            if(current instanceof Automaton && ((InputTableModel)table.getModel()).isMultiple){
            	int spot = this.getMachineIndexBySelectedRow(table);
            	Automaton cur = null;
            	if(spot != -1) cur = (Automaton)machines.get(spot);
            	else cur = (Automaton)this.getEnvironment().getObject();
                
                    AutomatonPane newAP = new AutomatonPane(cur);
                    newAP.addMouseListener(new ArrowDisplayOnlyTool(newAP, newAP.getDrawer()));
                    JSplitPane split = SplitPaneFactory.createSplit(getEnvironment(), true,
                            0.5, newAP, myPanel);
                    MultiplePane mp = new MultiplePane(split);
                    
                    EnvironmentFrame frame = Universe.frameForEnvironment(getEnvironment());
                    String newTitle = cur.getFileName();
                    if(newTitle != "") frame.setTitle(newTitle);
                    getEnvironment().remove(getEnvironment().getActive());
     
                    
                    getEnvironment().add(mp, getComponentTitle(), new CriticalTag() {
                    });
                    getEnvironment().setActive(mp);
                
            }
            else if(current instanceof Grammar && (table.getSelectedRow() < (table.getRowCount()-1))){
            	int spot = this.getMachineIndexBySelectedRow(table);
            	Grammar cur = null;
            	if(spot != -1) cur = (Grammar)machines.get(spot);
            	else cur = (Grammar)this.getEnvironment().getObject();
                
	                BruteParsePane bp = new BruteParsePane((GrammarEnvironment)getEnvironment(), cur, null);
	                int column = 1;
	                if(spot == -1) column = 0;
	               bp.inputField.setText((String)table.getModel().getValueAt(table.getSelectedRow(), column));
	               //bp.inputField.setEnabled(false); 
                   bp.inputField.setEditable(false);              
	                JSplitPane split = SplitPaneFactory.createSplit(getEnvironment(), true,
	                        0.5, bp, myPanel);
	                MultiplePane mp = new MultiplePane(split);
	                getEnvironment().add(mp, getComponentTitle(), new CriticalTag() {
	                });
	                
	                EnvironmentFrame frame = Universe.frameForEnvironment(getEnvironment());
	                String newTitle = cur.getFileName();
                    if(newTitle != "") frame.setTitle(newTitle);
	                getEnvironment().remove(getEnvironment().getActive());
	 
	                
	                getEnvironment().add(mp, getComponentTitle(), new CriticalTag() {
	                });
	                getEnvironment().setActive(mp);
	            
            }
    }

    /**
	 * This auxillary class is convenient so that the help system can easily
	 * identify what type of component is active according to its class.
	 */
	public class MultiplePane extends JPanel {
		public MultiplePane(JSplitPane split) {
			super(new BorderLayout());
			add(split, BorderLayout.CENTER);
			mySplit = split;
		}
		public JSplitPane mySplit = null;
	}
	
	
	private boolean isAlreadyExecuted(ArrayList<String> list, String testCase){
		
		Iterator<String> itList = list.iterator();
		while(itList.hasNext()){
			String str = itList.next();
			if(testCase.equals(str)){ 
				return true;
			}
		}
		return false;
	}
	
	/**
	 * ********************* New method! ***************************
	 * Given a JFLAP automaton, this will return the corresponding Plavis format encoding
	 * of the structure.
	 * 
	 * @author arineiza
	 * 
	 * @param auto
	 */
//	private BasicFileWriter writeFieldsPlavis(Automaton auto) {
//		// Add the states as subelements of the structure element.
//		//State[] states = auto.getStates();
//		
//		File fLocalDir = new File("").getAbsoluteFile();
//		String strLocalDir = fLocalDir.getPath()+"//Methods";
//		File fMethodsDir = new File(strLocalDir);
//		BasicFileWriter plavisFile = new BasicFileWriter(fMethodsDir.getPath()+"//fsm.txt");
//		
//		plavisFile.open();
//		
//		State initialState = auto.getInitialState();
//		try{
//			Transition[] transFromInitialState = auto.getTransitionsFromState(initialState);
//			for(int i = 0; i < transFromInitialState.length; i++){
//				plavisFile.writeLine(transFromInitialState[i].getFromState().getName()+" -- "+
//						transFromInitialState[i].getDescription().toString().subSequence(0, 1)+" / "+
//						transFromInitialState[i].getDescription().toString().subSequence(4, 5)+" -> "+
//						transFromInitialState[i].getToState().getName());
//				plavisFile.newLine();
//			}
//			
//			Transition[] transitions = auto.getTransitions();
//			for(int i = 0; i < transitions.length; i++){
//				if(!transitions[i].getFromState().equals(initialState)){
//					plavisFile.writeLine(transitions[i].getFromState().getName()+" -- "+
//							transitions[i].getDescription().toString().subSequence(0, 1)+" / "+
//							transitions[i].getDescription().toString().subSequence(4, 5)+" -> "+
//							transitions[i].getToState().getName());
//					plavisFile.newLine();
//				}
//			}
//		}
//		catch(Exception e){
//			System.out.println("automato are not ready yet!");
//		}
//			
//		
////		//Header Plavis File
////		plavisFile.writeLine("estado FSMmain ou subestados ");	
////		for (int i = 0; i < states.length; i++){
////			if(i!=0)
////				plavisFile.writeLine(", ");
////			plavisFile.writeLine(states[i].getName());
////			if(auto.getInitialState().getName().equals(states[i].getName()))
////				plavisFile.writeLine(" def");
////        }
////		plavisFile.newLine();
////		
////		//Add the States
////        for (int i = 0; i < states.length; i++){
////			plavisFile.writeLine("estado "+states[i].getName()+" atomo\n");
////        	//System.out.println("estado "+states[i].getName()+" atomo");
////        }
////        plavisFile.writeLine(" ; \n");
////        //System.out.println(" ; ");
////        
////		// Add the transitions
////		//Transition[] transitions = auto.getTransitions();
////		
////		for (int i = 0; i < transitions.length; i++){
//////			System.out.println("evento "+transitions[i].getDescription().toString().subSequence(0, 1)+
//////					           " origem "+transitions[i].getFromState().getName()+
//////					           " destino "+transitions[i].getToState().getName()+
//////					           " acao { s"+transitions[i].getDescription().toString().subSequence(4, 5)+" }");
////			plavisFile.writeLine("evento "+transitions[i].getDescription().toString().subSequence(0, 1)+
////					           " origem "+transitions[i].getFromState().getName()+
////					           " destino "+transitions[i].getToState().getName()+
////					           " acao { s"+transitions[i].getDescription().toString().subSequence(4, 5)+" }\n");
////		}
////		plavisFile.writeLine(" ; \n");
////		//System.out.println(" ; ");
////		
//		plavisFile.close();
//	    
//	    return plavisFile;
//	}
	
	
	//The automaton encoded in the Plavis' file format
	private BasicFileWriter plavisEncode;
	
	protected JTable table = null;
    
	private static String[] RESULT = { "Accept", "Reject", "Cancelled" };
    
    protected JPanel myPanel = null;

	private static Color[] RESULT_COLOR = { Color.green, Color.red, Color.black };
	
	private Automaton automaton;
	
	private Environment environment;
}